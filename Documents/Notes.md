Dump clang ast:
---------------
clang -Xclang -ast-dump [-fsyntax-only] 
clang-check <path> -ast-dump -ast-dump-filter <filter> [--]

Get the list of tokens:
-----------------------
clang-check <path> -ast-list [--]

Cool tools:
-----------
clang-modernize

Dump class layout:
------------------
clang -cc1 -fdump-record-layouts <path>

Get llvm object file:
---------------------
clang -c <path> -flto 

Demangle C++ symbols:
---------------------
c++filt -n <path>

Milestone 1
===========

1. Discuss the architecture of the protection mechanism to be implemented
-------------------------------------------------------------------------
Protect all virtual function callsites to make sure they only call function from
the correct hierarchy by putting all virtual tables aligned to a certain power
of two in memory and making a bit cast check and a comparaison to check that we
dereference the right virtual table. Given the hierarchy of class (with no
multiple inheritance) we can lay them in memory as nested lists (top-left right
traversal of the inheritance tree).


2. View clang AST generated for simple C++ programs with classes and virtual functions
--------------------------------------------------------------------------------------
clang-check Virtual.cpp -ast-dump --


3. Print C++ class hierarchy based on clang AST 
-----------------------------------------------
see llvm/tools/clang/tools/extra/hierarchy


4. Print all virtual function callsites in the program, along with the information about static type of the object whose method is being called 
-----------------------------------------------------------------------------------------------------------------------------------------------
see llvm/tools/clang/tools/extra/virtual-calls


5. Find out when and how virtual tables are generated by clang, print all virtual tables during compilation
-----------------------------------------------------------------------------------------------------------
In lldb do:
    b ItaniumCXXABI::emitVTableDefinitions

Step until linkage+initializer+visibility+alignment are set and then:
    expr VTable->dump()

    
Interesting functions:
----------------------
    CodeGen/CDCXXABI.h =>
    /// Perform a derived-to-base, base-to-derived, or bitcast member
    /// pointer conversion.
    virtual llvm::Value *EmitMemberPointerConversion(CodeGenFunction &CGF,
                                                   const CastExpr *E,
                                                   llvm::Value *Src);

    /// Perform a derived-to-base, base-to-derived, or bitcast member
    /// pointer conversion on a constant value.
    virtual llvm::Constant *EmitMemberPointerConversion(const CastExpr *E,
                                                      llvm::Constant *Src);

    virtual llvm::Value *GetVirtualBaseClassOffset(CodeGenFunction &CGF,
                                                 llvm::Value *This,
                                                 const CXXRecordDecl *ClassDecl,
                                        const CXXRecordDecl *BaseClassDecl) = 0;

    virtual llvm::Value *GetVirtualBaseClassOffset(CodeGenFunction &CGF,
                                                 llvm::Value *This,
                                                 const CXXRecordDecl *ClassDecl,
                                        const CXXRecordDecl *BaseClassDecl) = 0;

    void emitVTableDefinitions(CodeGenVTables &CGVT, const CXXRecordDecl *RD)
    
    /// Get the address point of the vtable for the given base subobject while
    /// building a constructor or a destructor. On return, NeedsVirtualOffset
    /// tells if a virtual base adjustment is needed in order to get the offset
    /// of the base subobject.  
    llvm::Value *getVTableAddressPointInStructor(CodeGenFunction &CGF, 
        const CXXRecordDecl *RD, BaseSubobject Base, 
        const CXXRecordDecl *NearestVBase, bool &NeedsVirtualOffset) = 0;
    
    /// Get the address point of the vtable for the given base subobject while
    /// building a constexpr.
    virtual llvm::Constant *
    getVTableAddressPointForConstExpr(BaseSubobject Base,
                                    const CXXRecordDecl *VTableClass) = 0;

    /// Get the address of the vtable for the given record decl which should be
    /// used for the vptr at the given offset in RD.
    virtual llvm::GlobalVariable *getAddrOfVTable(const CXXRecordDecl *RD,
                                                CharUnits VPtrOffset) = 0;

    /// Build a virtual function pointer in the ABI-specific way.
    virtual llvm::Value *getVirtualFunctionPointer(CodeGenFunction &CGF,
                                                 GlobalDecl GD,
                                                 llvm::Value *This,
                                                 llvm::Type *Ty) = 0;


Notes:
Use dynamic linking



Milestone 2
===========

1. Decide which information about class hierarchy, virtual tables and virtual calls is necessary in order to compute and enforce virtual tables layout and insert checks as required for the protection mechanism. 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Full class hierarchy, relation between classes and virtual tables. We will add
this information in metadata format. We also need to mark all the locations of a
virtual function load.

2. Find out which of these information is already present in LLVM IR, and which needs to be added. Discuss this findings in person. 
-----------------------------------------------------------------------------------------------------------------------------------
There is type information in LLVM IR, but we cannot rely on it, compiling with
-fno-rtti does not preserve that information.

3. Modify clang to preserve necessary information when it emits LLVM IR. 
------------------------------------------------------------------------
see CodeGenModule::Release() in lib/CodeGen/CodeGenModule.cpp.

CodeGenModule::EmitCPSVirtualMetadata => for hierarchy and vtables

CodeGenFunction::GetFunctionPtr => for marking virtual table loads

4. Make sure that the modified clang successfully runs on all SPEC2006 benchmarks and manually verify its correctness on a sample from the benchmarks.
------------------------------------------------------------------------------------------------------------------------------------------------------


Milestone 3
===========

1. Implement an LLVM pass that would enforce the layout of the virtual tables that is required to implement fast checks for the protection mechanism. For now, assume that the pass runs at linktime optimizations phase and has complete information about all classes and virtual tables in the entire program.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


2. Schedule the pass to run during linktime optimizations (e.g., similar to the CPI pass or the SafeStack pass).
----------------------------------------------------------------------------------------------------------------


3. Make sure that clang/llvm with the pass being implemented can successfully compile all SPEC2006 benchmarks and the resulting benchmarks run correctly. Manually verify the correctness of the pass on a sample from the benchmarks.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Double dereference for global var for GEP
put the pass in transformations

Test templates to understand what dependent type is and understand if it is
important

Understand how to modify securely LLVM IR
