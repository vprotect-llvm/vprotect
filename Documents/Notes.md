Dump clang ast:
---------------
clang -Xclang -ast-dump [-fsyntax-only] 
clang-check <path> -ast-dump -ast-dump-filter <filter> [--]

Get the list of tokens:
-----------------------
clang-check <path> -ast-list [--]

Cool tools:
-----------
clang-modernize

Dump class layout:
------------------
clang -cc1 -fdump-record-layouts <path>

Get llvm object file:
---------------------
clang -c <path> -flto 

Demangle C++ symbols:
---------------------
c++filt -n <path>

Milestone 1
===========

1. Discuss the architecture of the protection mechanism to be implemented
-------------------------------------------------------------------------
Protect all virtual function callsites to make sure they only call function from
the correct hierarchy by putting all virtual tables aligned to a certain power
of two in memory and making a bit cast check and a comparaison to check that we
dereference the right virtual table. Given the hierarchy of class (with no
multiple inheritance) we can lay them in memory as nested lists (top-left right
traversal of the inheritance tree).


2. View clang AST generated for simple C++ programs with classes and virtual functions
--------------------------------------------------------------------------------------
clang-check Virtual.cpp -ast-dump --


3. Print C++ class hierarchy based on clang AST 
-----------------------------------------------
see llvm/tools/clang/tools/extra/hierarchy


4. Print all virtual function callsites in the program, along with the information about static type of the object whose method is being called 
-----------------------------------------------------------------------------------------------------------------------------------------------
see llvm/tools/clang/tools/extra/virtual-calls


5. Find out when and how virtual tables are generated by clang, print all virtual tables during compilation
-----------------------------------------------------------------------------------------------------------
How is the virtual table layout/ class Layout in Itanium  ?
Overload by return type in C++ ????
Add padding to base classes for copying specialized classes ?

CodeGen/CDCXXABI.h =>
    /// Perform a derived-to-base, base-to-derived, or bitcast member
    /// pointer conversion.
    virtual llvm::Value *EmitMemberPointerConversion(CodeGenFunction &CGF,
                                                   const CastExpr *E,
                                                   llvm::Value *Src);

    /// Perform a derived-to-base, base-to-derived, or bitcast member
    /// pointer conversion on a constant value.
    virtual llvm::Constant *EmitMemberPointerConversion(const CastExpr *E,
                                                      llvm::Constant *Src);

    virtual llvm::Value *GetVirtualBaseClassOffset(CodeGenFunction &CGF,
                                                 llvm::Value *This,
                                                 const CXXRecordDecl *ClassDecl,
                                        const CXXRecordDecl *BaseClassDecl) = 0;

    virtual llvm::Value *GetVirtualBaseClassOffset(CodeGenFunction &CGF,
                                                 llvm::Value *This,
                                                 const CXXRecordDecl *ClassDecl,
                                        const CXXRecordDecl *BaseClassDecl) = 0;

    void emitVTableDefinitions(CodeGenVTables &CGVT, const CXXRecordDecl *RD)
    
    /// Get the address point of the vtable for the given base subobject while
    /// building a constructor or a destructor. On return, NeedsVirtualOffset
    /// tells if a virtual base adjustment is needed in order to get the offset
    /// of the base subobject.  
    llvm::Value *getVTableAddressPointInStructor(CodeGenFunction &CGF, 
        const CXXRecordDecl *RD, BaseSubobject Base, 
        const CXXRecordDecl *NearestVBase, bool &NeedsVirtualOffset) = 0;
    
    /// Get the address point of the vtable for the given base subobject while
    /// building a constexpr.
    virtual llvm::Constant *
    getVTableAddressPointForConstExpr(BaseSubobject Base,
                                    const CXXRecordDecl *VTableClass) = 0;

    /// Get the address of the vtable for the given record decl which should be
    /// used for the vptr at the given offset in RD.
    virtual llvm::GlobalVariable *getAddrOfVTable(const CXXRecordDecl *RD,
                                                CharUnits VPtrOffset) = 0;

    /// Build a virtual function pointer in the ABI-specific way.
    virtual llvm::Value *getVirtualFunctionPointer(CodeGenFunction &CGF,
                                                 GlobalDecl GD,
                                                 llvm::Value *This,
                                                 llvm::Type *Ty) = 0;




Milestone 2
===========

1. Decide which information about class hierarchy, virtual tables and virtual
calls is necessary in order to compute and enforce virtual tables layout and
insert checks as required for the protection mechanism. 
-----------------------------------------------------------------------------


2. Find out which of these information is already present in LLVM IR, and which
needs to be added. Discuss this findings in person. 
-------------------------------------------------------------------------------


3. Modify clang to preserve necessary information when it emits LLVM IR. 
------------------------------------------------------------------------


4. Make sure that the modified clang successfully runs on all SPEC2006
benchmarks and manually verify its correctness on a sample from the benchmarks.
-------------------------------------------------------------------------------
